#include <stdio.h>
int h[101]; // 用来存放堆的数组
int n; // 用来存放堆中元素的个数，也就是堆的大小

// 交换函数，用来存储堆中元素的个数，也就是堆的大小
void swap(int x, int y)
{
	int t;
	t = h[x];
	h[x] = h[y];
	h[y] = t;
}

void siftdown(int i) // 传入一个需要向下调整的节点编号i，这里传入1，即从堆的顶点开始向下调整
{
	int t, flag = 0; // flag用来标记是否需要继续向下调整
	// 当i结点有儿子（其实是至少有左儿子的情况下）并且有需要继续调整的时候，循环就执行
	while (i*2 <= n && flag == 0)
	{
		// 首先判断它和左儿子的关系，并用t记录值较小的结点编号
		if (h[i] > h[i*2])
			t = i * 2;
		else
			t = i;
		// 如果它有右儿子，再对右儿子进行讨论
		if (i*2+1 <= n)
		{
			// 如果右儿子的值更小，更新较小的结点编号
			if (h[t] > h[i*2+1])
				t = i*2+1;
		}
		// 如果发现最小的结点编号不是自己，说明子结点中有比父结点更小的
		if (t != i)
		{
			swap(t, i); // 交换它们，注意swap函数需要自己来写
			i = t; // 更新i为刚才与它交换的儿子结点的编号，便于接下来继续向下调整
		}
		else
			flag = 1; // 否则说明当前的父结点已经比两个子结点都要小了，不需要再进行调整了
	}
}

void siftup(int i) // 传入一个需要向上调整的结点编号i
{
	int flag = 0; // 用来标记是否需要继续向上调整
	if (i == 1)
		return; // 如果是堆顶，就返回，不需要调整了
	// 不在堆顶，并且当前结点i的值比父结点小的时候就继续向上调整
	while (i != 1 && flag == 0)
	{
		// 判断是否比父结点的小
		if (h[i] < h[i/2])
			swap(i, i/2); // 交换它和它爸爸的位置
		else
			flag = 1; // 表示已经不需要调整了，当前结点的值比父结点的值要大
		i = i / 2; // 这句话很重要，更新编号i为它父结点的编号，从而便于下一次继续向上调整
	}
}

// 建立堆的函数
void creat()
{
	int i;
	// 从最后一个非叶结点到第1个结点依次进行向上调整
	for (i = n/2; i >= 1; i--)
	{
		siftdown(i);
	}
}

int main()
{
	// 创建堆
	for (i = n/2; i >= 1; i--)
		siftdown(i);

	n = 0;
	for (i = 1; i <= m; i++)
	{
		n++;
		h[n] = a[i]; // 或者写成scanf("%d", &h[n]);
		siftup(i);
	}

	return 0;
}
